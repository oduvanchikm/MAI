# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Губарева М.К.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Списки — важная структура в языке Пролог. Списки позволяют хранить произвольное количество данных. Связный список — структура данных, состоящая из узлов. Узел содержит данные и ссылку (указатель, связку) на один или два соседних узла. Списки языка Пролог являются односвязными, т.е. каждый узел содержит лишь одну ссылку.

При работе с односвязными списками необходимо выделять первый узел (называемый головой списка), остальные узлы (хвост списка). Хвост списка является таким же списком, как и исходный, поэтому обрабатывается аналогичным образом (рекурсивно).

## Задание 1.1: Предикат обработки списка

Реализация стандартных предикатов обработки списков

Предика ```my_length``` рекурсивно вычисляет длину списка. Сначала проверяет, когда список пустой,длина равна 0.
Далее отбрасываем первый элемент списка и рекурсивно вызываем ```my_length``` для оставшейся части списка. Затем к результату вызова добавляем 1, чтобы учесть отброшенный элемент.
```prolog
my_length([], 0).
my_length([_|L], N) :- my_length(L, M), N is M + 1.
```

Предикат ```my_member``` проверяет, принадлежит ли элемент списку. Сначала смотрим, если первый элемент списка равен X, в этом случае X принадлежит списку. В рекурсивном случае мы отбрасываем первый элемент списка и рекурсивно вызываем ```my_member``` для оставшейся части списка. Если X принадлежит оставшейся части списка, то X также принадлежит исходному списку.
```prolog
my_member(X,[X|_]).
my_member(X,[_|T]) :- my_member(X,T).
```

Предикат ```my_append``` объединяет два списка в один. Если первый список пустой, то результат - второй список.
Далее берем первый элемент первого списка и добавляем его в конец результата, затем рекурсивно вызываем ```my_append``` для оставшейся части первого списка и второго списка. Результатом будет объединение двух списков.
```prolog
my_append([],Y,Y).
my_append([X|T],Y,[X|Z]) :- my_append(T,Y,Z).
```

Предикат ```my_remove``` удаляет элемент из списка. Если список пустой, то результат - пустой список. Далее проверяем, является ли первый элемент списка равным X. Если да, то мы пропускаем его и рекурсивно вызываем ```my_remove``` для оставшейся части списка. Результатом будет список без первого вхождения элемента X.
```prolog
my_remove(X,[X|T],T).
my_remove(X, [H|T], [H|R]) :- my_remove(X, T, R).
```

Предикат ```my_permute``` реализует перестановку элементов списка. Если список пустой, то результат - пустой список. Далее выбираем первый элемент списка X, удаляем его из списка L с помощью предиката ```my_remove``` и рекурсивно вызываем ```my_permute``` для оставшейся части списка Y. Результатом будет список, в котором первый элемент X перемещен в различные позиции.
```prolog
my_permute([], []).
my_permute(L, [X|T]) :- my_remove(X, L, Y), my_permute(Y, T).
```

Предикат ```my_sublist``` определяет подсписок списка S. Используем предикат ```my_append``` для получения всех возможных комбинаций подсписков. Далее ииспользуем предикат ```my_append``` для получения всех возможных комбинаций подсписков X из списка S. Затем вызываем ```my_sublist``` для оставшейся части списка и добавляем полученные подсписки в результат R.
```prolog
my_sublist(S, R) :- my_append(X, _, S), my_append(_, R, X).
```

### Вариант 7

```truncation1(A,L,R)``` - усечение списка до указанной длины

Примеры использования:
```prolog
?- truncation1([3,5,4,6,4,4,47,8,9,9,6],3,R).
R = [3,5,4].
?- truncation2([3,5,4,47,8,9,9,6],6,R).
R = [3,5,4,47,8,9].
```

Реализация:
```prolog
% Реализация на основе стандартных предикатов
truncation1(A,L,R) :- 
    my_append(R, _, A), 
    my_length(R, L), !.

% Реализация без стандартных предикатов
truncation2(_,0,[]).
truncation2([H|T],L,[H|RT]) :- 
    L1 is L - 1, 
    truncation2(T, L1, RT), !.
```

Предикат усечения списка до указанной длины принимает три аргумента: исходный список, число элементов, которые нужно оставить и результат, в него будут помещены оставшиеся элементы.

`truncation1(A,L,R)` - используем предикат my_append, который добавляет элементы в конец списка. Сначала мы добавляем в R произвольное количество элементов из A с помощью _. Затем определяем длину списка R при помощи предиката ```my_length```. Если длина R равна L, то мы достигли нужной длины и можем прекратить работу. Если же длина R меньше L, то продолжаем добавлять элементы из A в R до тех пор, пока длина не станет равной L.

`truncation2(_,0,[])` - сначала проверяем, если длина равна 0, то возвращаем пустой список []. Затем рекурсивно вызываем предикат для списка T и длины L - 1. Добавляем головной элемент H в начало списка RT, который является результатом рекурсивного вызова. Получаем список RT, содержащий первые L элементов из списка.

Оператор ! возвращает первое найденное решение.

## Задание 1.2: Предикат обработки числового списка

### Вариант 13
```arprogression2(L), arprogression1(List)``` - проверяем список на арифметическую прогрессию. 

Реализация:
```prolog
% Реализация на основе стандартных предикатов
arprogression1(List) :-
    my_length(List, Length),
    Length >= 3, 
    arprogression(List, Difference). 

arprogression([X,Y,Z|T],D):-!,
    X - Y =:= Y - Z,
    arprogression([Y,Z|T],D).
arprogression(_,_).

% Реализация без стандартных предикатов

arprogression2([X,Y,Z|T]):-!,
    X - Y =:= Y - Z,
    arprogression2([Y,Z|T]).
arprogression2(_).
```
Примеры использования:
```prolog
?- arprogression1([3,4,5]).
true
?- arprogression1([22,13,44,15]).
false
?- arprogression2([22,13,44,15]).
false
?- arprogression2([22,13,44,15]).
true
```
Предикат проверки списка на арифметическую програссию принимает один аргумент: исходный список, далее возвращает либо true, либо false

```arprogression2(L).``` Сравниваем разности первого и второго с разностью второго и третьего элементов. Если равенство не выполняется, то выводим false, если выполняется, то продолжаем сравнение уже без первого элемента.
Пример совместного использования предикатов:

```arprogression1(List).``` В арифметической прогрессии не менее трех элементов, поэтому проверяем с помощью предиката ```my_length``` длину списка, если длина списка меньше 3, то выводим false, если три и более элементов, то проверяем пары чисел, являются ли они арифметической прогрессией.

## Пример совместного использования предикатов 1.1 и 1.2:
Усечение исходного списка до указанной длины, затем проверка списка на арифметическую прогрессию.

```prolog
new_arithmprogres(A,L1) :- 
    truncation1(A,L1,L2), 
    arprogression2(L2).
new_arithmprogres(_,_).
```

## Задание 2: Реляционное представление данных

Реляционное представление - это способ организации и хранения данных в базе данных, основанный на использовании таблиц.
Реляционное представление баз данных имеет множество преимуществ, таких как возможность простого и удобного доступа к данным, возможность использования различных типов данных и обеспечение целостности данных. Однако, при работе с большими объемами данных, реляционная модель может столкнуться с ограничениями производительности и масштабируемости. База данных занимает достаточно большой объем внешней памяти, а также скорость доступа к данным не самая высокая. Сложность запросов может быть высокой, особенно если в базе данных содержится большое количество связанных таблиц. Несмотря на это, реляционное представление все еще остается одним из наиболее популярных и широко используемых способов организации и хранения данных в базах данных.

В файле three.pl данные представлены в виде фактов, что позволяет удобно искать нужную информацию, но может привести к сохранению большого объема неиспользуемых данных при каждой итерации.

Описание:
```average(Student, Res).``` - просматриваются все оценки студента, предикат ```length(Grade, Number).``` ищет количество элементов (количество оценок), предикат ```sum(Grade, Summa).``` вычисляет сумму всех оценок студентов, далее находится средняя оценка: сумма оценок студента делится на количество оценок студента.

```prolog
average(Student, Res) :-
    student(_, Student, Grade),
    length(Grade, Number),
    sum(Grade, Summa),
    Res is Summa / Number.
```

```sum(Grade, Summa).``` - (список, результат: сумма элементов). Вычисляет сумму всех элементов списка.

```prolog
sum([],0).
sum([grade(_,M)|T],S) :- 
    sum(T,Y),
    S is Y + M.
```

```pass(StudentsPassed).``` - предикат проверяет, сдал ли студент экзамен, если у него есть хотя бы одна 2, то алгоритм выводит false. ```student(_,Students,Marks).``` - смотрим фамилию студента и его оценки. ```not(member(grade(_,2),Marks)).``` - проверяем, входит ли "2", если есть хотя бы одна "2", то студент не сдал экзамен.

```prolog
pass(StudentsPassed):-
  student(_,Students,Marks),
  not(member(grade(_,2),Marks)).
  ```

```failstudents(Subject,N).``` - ищет количество студентов, не сдавших экзамен. ```subject(M,Subject).``` - создается список, содержащий списки из оценок всех студентов по всем предметам. ```findall(A,(student(_,_,A),gradeInList(A,M)),AllMarks).``` - находит все оценки (A) студентов и сохраняет их в списке AllMarks. ```length(AllMarks,N).``` - предикат подсчитывает количество оценок.

```prolog
failstudents(Subject,N):-
	subject(M,Subject),
	findall(A,(student(_,_,A),gradeInList(A,M)),AllMarks), 
	length(AllMarks,N).
```

```gradelist([grade(Subject,2)|_],Subject).``` - используется для поиска оценок "2" по определенному предмету.  

```prolog
gradelist([grade(Subject,2)|_],Subject). 
gradelist([_|T],Subject):-
	gradelist(T,Subject).
```

```highscore(Group,N).``` - (группа, список учеников с максимальным средним баллом). Предикат ищет студентов  максимальным средним баллом. ```findall(Mark, (student(Group,Stud,_), average(Stud,Mark)),Marks).``` - собираем список со всеми средними оценками. ```max(Marks,Res)``` - предикат ищет максимальный средний балл. ```findall(A,(student(Group,A,_), average(A,M), M == Res), N)``` - составляем список из всех студентов имеющих такую оценку. 

```prolog
highscore(Group,N):-
  findall(Mark, (student(Group,Stud,_), average(Stud,Mark)),Marks),
  max_list(Marks,Res),
  findall(A,(student(Group,A,_), average(A,M), M == Res), N),!.
```

```max_list([X], X)``` - предикат ищет максимальный элемент в списке.

```prolog
max_list([X], X).
max_list([X|Xs], Max) :-
    max_list(Xs, TempMax),
    Max is max(X, TempMax).
```

Примеры использования: 
```prolog
?- average('Мышин',X).
X = 3.6666666666666665
?- pass('Мышин').
true
?- average('Эфиркина',X).
X = 3.8333333333333335
?- pass('Эфиркина').
true
?- failstudents('Математический анализ',X).
X = 3
?- failstudents('Информатика',X).
X = 3
?- highscore(102,X).
X = ['Азурин']
```

## Выводы
Эта лабораторная работа стала для меня первым опытом написания программ на Прологе. За время выполнения работы я не только научилась работе со списками, но и стала лучше понимать Пролог и его отличие от императивных языков. Я думаю, переход с императивных языков программирования на декларативный, Пролог, представляет собой уникальный опыт. В императивных языках мы указываем как что-либо сделать, в Прологе - что необходимо сделать, это является главным отличием и непрерывычным в работе моментом. 
Несмотря на первоначальные трудности, Пролог учит увидеть программирование под новым углом. Он предлагает уникальный подход к разделению большой задачи на ряд меньших, создавая структурированный путь к решению. По окончании работы я стала лучше понимать пролог, научилась работать со списками, хоть это было достаточно сложно.
